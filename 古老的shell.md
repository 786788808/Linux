工作中常用到shell script实现调用，记录一下          
### 1.什么是shell
刚开始接触shell的时候，只知道shell脚本扩展名为 sh，其脚本还带有linux命令……脚本读起来有点困难，一脸问号   
慢慢……知道了一点东西  
shell，直译外壳，它是操作系统的外壳。我们可以通过shell命令来操作和控制操作系统。可理解成，Shell是一个命令解释器，它通过接受用户输入的Shell命令来启动、暂停、停止程序的运行或对计算机进行控制。  
说人话一点，可以把shell比喻成一个翻译官，我写了人类能看懂的脚本（ABCDEFG……），想要计算机去帮我干活，但是计算机它只懂机器语言（0101010101），在这种鸡同鸭讲的情况下，于是请来了shell来当翻译官，将人类的指令翻译成机器能识别的语言，然后让机器去干活。  
不过，我们常说的shell指的是shell script，而不是开发shell本身这意思。    
所有linux命令，可以直接在shell当中被调用。    
AND shell 区分大小写。  

### 2.shel的种类
Linux的Shell种类众多，常见的有：  
- Bourne Shell（/usr/bin/sh或/bin/sh）
- **Bourne Again Shell（/bin/bash）**
- C Shell（/usr/bin/csh）
- K Shell（/usr/bin/ksh）
- Shell for Root（/sbin/sh）  

它们由不同的人或组织、实验室研发出来（各有优缺点，详情请google），我们常用的就是 Bourne Again Shell，缩写: bash .它是linux标准的默认shell ，它基于Bourne shell，吸收了C shell和Korn shell的一些特性。bash完全兼容sh，也就是说，用sh写的脚本可以不加修改的在bash中执行。  
可通过以下命令查询自己的linux支持什么shell：cat ./etc/shells    
![image](https://user-images.githubusercontent.com/32427537/149654418-efd18470-1a82-4481-909f-de9330839140.png)     
可通过echo $SHELL查看默认shell: （这只是其中一种查看方式）     
![image](https://user-images.githubusercontent.com/32427537/149655156-a37babc9-ac44-41af-902e-0e8a4d3659f7.png)    

### 3.#!/bin/sh 表明解释器信息  
shell script第一行，常见：**#!/bin/sh** or **#!/bin/bash**    
#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。沿着给定的路径去找就是了。（不懂的别纠结，学多几门语言就知道了）    
e.g.我们已经在hush1目录下，有test_hello_world.sh了:    
![image](https://user-images.githubusercontent.com/32427537/149659528-e47afc31-b373-4719-a83e-5eda944af7cb.png)    

我们想要执行这份shell script,有两种方式执行脚本。    
- 法1：./test_hello_world.sh  
- 法2：sh test_hello_world.sh  

![image](https://user-images.githubusercontent.com/32427537/149659714-96c6e627-936b-49c2-8192-3e735b6e14b1.png)  
法2sh，不需要在第一行指定解释器信息，写了也没用  

### 4.变量
变量命名规则：变量名称可由字母、数字和下划线组成，但是**不能以数字开头**。并且不能使用shell里面的关键字。  
在bash中，变量的默认类型是字符串类型。如果要进行数值运算，则必须指定变量类型为数值型。  

### 5.输入输出重定向
 | 设备      | 设备文件名     | 文件描述符     | 类型     |
| ---------- | :-----------:  | :-----------: | :-----------: |
| 键盘     | /dev/stdin     |  0     | 标准输入     |
| 显示器     | /dev/stdout     |  1     | 标准输出     |
| 显示器     | /dev/stderr     |  2     | 标准错误输出     |

因为设备文件名比较难记，就用0 1 2 分别来表示标准输入 标准输出 标准错误输出    
 输出重定向：一般的输出是，我们输入命令后，在显示器显示输出结果，但是重定向，就是把命令的结果输出到指定的文件当中。

 | 类型      | 符号     | 作用     |
| ---------- | :-----------:  | :-----------: |
| 标准输出重定向     | 命令 > 文件     |  以**覆盖**的方式，把命令的正确输出输出到指定的文件或设备当中     | 
|      | 命令 > 文件     |  以**追加**的方式，把命令的正确输出输出到指定的文件或设备当中     | 
| 标准错误输出重定向     | 错误命令 2>> 文件     |  以**覆盖**的方式，把命令的正确输出输出到指定的文件或设备当中    | 
|      | 错误命令 2>> 文件     |  以**追加**的方式，把命令的正确输出输出到指定的文件或设备当中    | 
| 正确输出和错误输出同时保存    | 命令 > 文件 2>&1    |  以**覆盖**的方式，把正确输出和错误输出都保存到同一个文件中    | 
|    | 命令 >> 文件 2>&1    |  以**追加**的方式，把正确输出和错误输出都保存到同一个文件中    | 
|    | 命令 &> 文件     |  以**覆盖**的方式，把正确输出和错误输出都保存到同一个文件中    | 
|    | 命令 &>> 文件     |  以**追加**的方式，把正确输出和错误输出都保存到同一个文件中    | 
|    | 命令 >> 文件1 2>> 文件2     |  **分开储存输出结果**，把**正确的输出追加到文件1**中，把**错误的输出追加到文件2**中 |

常用的是同时保存正确输出和错误输出，并且以追加方式保存 还有最后一种分开储存正确、错误输出的一种类型。  

### 6.多命令顺序执行
 | 多命令执行符      | 格式     | 作用     |
| ---------- | :-----------:  | :-----------: |
| ;     | 命令1 ; 命令2     |  多个命令顺序执行，命令之间没有任何逻辑联系     | 
|  &&    | 命令1 && 命令2     |  逻辑与，当命令1正确执行，则命令2才会执行；当命令1执行不正确，命令2也不会执行     | 
|  ||    | 命令1 || 命令2     |  逻辑或，当命令1正确执行，命令2不会执行；当命令1执行不正确，命令2才会执行     |

### 7.注释
单行注释，用经典的`#`开头  
多行注释，可以用多个`#`，也可以直接选用多行注释：    
`:<<EOF
注释内容...  
注释内容...  
注释内容...  
EOF`  
怎么理解多行注释呢？    
`:`冒号在Bash里也是一个命令，表示什么都不做，而`<<`是输入重定向，两个EOF(可用其它特殊成对字符替代)之间的内容通过<<追加给冒号（:），但是冒号对它们啥都不做，就相当于没做任何处理和输出，就相当于注释了

### 8.管道符
管道符`|`  
` 命令1 | 命令2`，将命令1的**正确输出**作为命令2的操作对象  

### 9.通配符和其他特殊符号
这个学过其他语言很好理解    
`?`,匹配任意一个符号    
`*`,匹配0个或任意多个任意字符，也就是可以匹配任意内容      
`[]`,匹配中括号中任意一个字符。例如，[abc]代表一定匹配一个字符，或者a,或者b,或者c      
`[-]`,匹配中括号中任意一个字符，在一个范围内，常见有[a-z],[0-9]    
`[^]`,逻辑非，匹配不是中括号内的一个字符。例如：[^0-9]代表匹配一个不是数字的字符  
单引号里的
双引号


### 10.判断
按照文件类型进行判断：  
 | 测试选项      | 作用     |
| ---------- | :-----------:  |
| `-d`     | 判断文件是否存在，并且是否为目录文件（是目录，则为真）     |
| `-e`     | 判断文件是否存在，存在就为真     |
| `-f`    | 判断该文件是否为真，是否为普通文件（是普通文件，则为真）     |

两种判断格式：    
`test -e etl_job.log`,判断 etl_job.log 这个文件是否存在    
`[ -e etl_job.log ]`,判断 etl_job.log 这个文件是否存在(中括号两边一定要留空格)      
输出结果要用`$?`来看（上一条命令的执行结果），如果输出结果为0，就代表正确；输出结果非零，就代表错误  
by the way,这么写去判断是因为机器要拿来判断，不是我们人眼去ls,然后看文件是否存在，是什么文件类型     
示例：  
![image](https://user-images.githubusercontent.com/32427537/156007257-e8e67354-f33c-445e-aa9e-3af0000da1e2.png)  
![image](https://user-images.githubusercontent.com/32427537/156008312-167e366a-1a9c-4f45-b423-e1964a951708.png)  
![image](https://user-images.githubusercontent.com/32427537/156009088-3c62efdb-1508-4a1f-84d6-ba736a222354.png)    
  
